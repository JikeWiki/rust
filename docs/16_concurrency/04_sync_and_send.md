# Sync和Send扩展并发

## 一、概述

rust语言本省的并发特性较少，目前将的并发特性都是来自标准库（而不是语言本身）。其实我们无需仅限于标准库的并发，可以自己实现并发。但在rust语言中有两个并发概念：`std::marker::Sync`和`std::marker::Send`这两个trait。

## 二、Send

Send：允许线程间转移所有权。实现Send trait的类型可以在线程间转移所有权，Rust中几乎所有的类型都实现了Send，但`Rc<T>`没有实现Send，它只用于单线程的场景。任何完全由Send组成的类型也被标记为Send，实际上除了原始指针之外，几乎所有的基础类型都实现了Send。

## 三、Sync

Sync：允许从多线程同时访问。实现Sync的类型可以安全的被多个线程引用，也就是说：如果`T`实现了`Sync`，那么`&T`（T的引用）就是实现了`Send`，表示`T`的引用可以被安全地送往另一个线程。基础类型都实现了Sync，完全由Sync类型组成的类型也是Sync，但是`Rc<T>`不是Sync，`RefCell<T>`和`Cell<T>`家族也不是Sync，而`Mutex<T>`实现了Sync。

## 四、手动实现Send和Sync很难保证安全

手动来实现Send和Sync是很难保证安全的，因为手动实现这些trait的时候涉及到使用特殊不安全的Rust代码，你需要非常谨慎地确保设计，才能满足线程间的安全性要求。
