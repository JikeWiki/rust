# RefCell<T>和内部可变性

## 一、内部可变性

内部可变性是Rust的设计模式之一，它允许你在只持有不可变引用的前提下进行修改。数据结构中使用了unsafe代码绕过rust正常的可变性和借用规则。

## 二、RefCell<T>

### 2.1 Rc<T>和RefCell<T>

与`Rc<T>`不同，`RefCell<T>`类型代表了其持有数据的唯一所有权。

我们先回忆一下借用规则

- 在任何给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用
- 引用总是有效的

`RefCell<T>`与`Box<T>`的区别如下

|                   Box<T>                   |                      RefCell<T>                       |
| ------------------------------------------ | ----------------------------------------------------- |
| 编译阶段强制代码遵循借用规则，否则出现错误 | 只会在运行时检查借用规则，没有满足借用规则则触发panic |

### 2.2 借用规则在不同阶段进行检查比较

在编译阶段检查，尽早暴露问题，没有运行时开销，对大多数场景是最佳选择，也是rust的默认行为。在运行时阶段检查，问题暴露延后，甚至影响到生产环境，因借用计数器产生些许性能损失，但实现了某些特定的内存安全场景（不可变环境中修改自身数据）。

针对编译器无法理解的代码，rust直接拒绝编译通过，避免产生问题。但如果开发者能够保证借用规则能满足，那么这个时候`RefCell<T>`就有它的勇武之处了。

### 2.3 RefCell<T>

与`Rc<T>`相似，只能用于但线程场景。

选择`Box<T>`、`Rc<T>`、`RefCell<T>`的依据

- Box<T>: 同一个数据拥有一个所有者，可变、不可变借用在编译时检查
- Rc<T>: 同一个数据拥有多个所有者，不可变引用在编译时检查
- RefCell<T>: 同一数据拥有过一个所有者，可变、不可变借用在运行时检查

其中，即便`RefCell<T>`本身不可变，但仍能修改其中存储的值

### 2.4 内部可变性，可变的借用一个不可变的值

借用规则有一个这样的推论，我们无法借用一个不可变的值。我们先看一个示例

```rust
fn main() {
    let x = 5;
    let y = &mut x;
}
```

上面的代码中，`x`是不可变的，让`y`借用一个`x`的可变引用，这样是不运行的，编译会发生报错。然而在某些情况下，我们需要这样一个值，它对外部是不可变的，但它同时能够在方法内部修改自身的值。除了这个数据的本身方法，其余的代码都不能修改这个值。

使用`RefCell<T>`就是获得这种内部可变性的一个方法，不过`RefCell<T>`并没有完全完全绕开借用规则，我们虽然使用内部可变性通过了编译阶段的借用检查，但借用检查仅仅是延后到了运行阶段而已，如果违反了借用规则，那么程序在运行时会出现panic。

下面我们来看一个示例

```rust
p91 05:07
```
