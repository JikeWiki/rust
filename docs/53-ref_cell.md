# RefCell<T>和内部可变性

## 一、内部可变性

内部可变性是Rust的设计模式之一，它允许你在只持有不可变引用的前提下进行修改。数据结构中使用了unsafe代码绕过rust正常的可变性和借用规则。

## 二、RefCell<T>

### 2.1 Rc<T>和RefCell<T>

与`Rc<T>`不同，`RefCell<T>`类型代表了其持有数据的唯一所有权。

我们先回忆一下借用规则

- 在任何给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用
- 引用总是有效的

`RefCell<T>`与`Box<T>`的区别如下

|                   Box<T>                   |                      RefCell<T>                       |
| ------------------------------------------ | ----------------------------------------------------- |
| 编译阶段强制代码遵循借用规则，否则出现错误 | 只会在运行时检查借用规则，没有满足借用规则则触发panic |

### 2.2 借用规则在不同阶段进行检查比较

在编译阶段检查，尽早暴露问题，没有运行时开销，对大多数场景是最佳选择，也是rust的默认行为。在运行时阶段检查，问题暴露延后，甚至影响到生产环境，因借用计数器产生些许性能损失，但实现了某些特定的内存安全场景（不可变环境中修改自身数据）。

针对编译器无法理解的代码，rust直接拒绝编译通过，避免产生问题。但如果开发者能够保证借用规则能满足，那么这个时候`RefCell<T>`就有它的勇武之处了。

### 2.3 RefCell<T>

与`Rc<T>`相似，只能用于但线程场景。

> P91 3:19
