# 生命周期

## 一、什么是生命周期？

Rust的每个引用都有生命周期，生命周期是可以理解是引用保持有效的作用域。大多数情况下，生命周期是隐式的、可被推断的。当引用的生命周期可能以不同的方式相互关联的时候，必须手动标注生命周期。

## 二、借用检查器

生命周期的主要目标是避免垂悬引用（dangling reference），如下示例的错误代码

```Rust
fn main() {
    {
        let r;
        {
            let x = 5;
            r = &x;
        }
        println!("r: {}", r);
    }
}
```

在最里层的大括号中，`r`指向了`x`，但是在最里层括号的外面，调用了`println!`，编译会报错，因为在最里层括号外面，`x`已经被释放了。rust为了保证程序的安全性，任务基于`r`的操作无法正常运行。

Rust编译器的借用检查器，用来比较引用的作用域从而判断所有的借用是否合法。如下加上注释的示例代码

```Rust
fn main() {
    {
        let r;                  // ------+-- 'a
        {                       //
            let x = 5;          // ------+- 'b
            r = &x;             // 
        }                       // ------+- 'b
        println!("r: {}", r);   //
    }                           // ------+-- 'a
}
```

可以看到`x`的生命周期比它的引用者`r`要短，所以rust不允许编译通过。要解决这个问题，必须让`x`的生命周期不小于`r`的生命周期。如下示例代码

```Rust
fn main() {
    let x = 5;
    let r = &x;

    println!("r: {}", r);
}
```

在以上代码中，`x`的生命周期完全覆盖了它的调用者`r`的生命周期，所以能顺利通过编译。

## 三、函数中的泛型生命周期

我们先看下面一段错误的代码

```Rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_string(), string2);

    println!("The longest string is {}", result);
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

在以上代码中，`longest`函数的目的是返回两个字符串中比较长的值，并在`main`函数中打印出来。传入参数为`x`和`y`两个字符串切片，返回值也是字符串切片。`x`和`y`的生命周期可能不一样，而返回的值生命周期应当是确定的，但是函数签名里返回的值不知道借用自`x`还是`y`，所以代码编译时会产生错误。

我们先给出一个解决方案，如下示例代码

```Rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

在以上代码中`'a`代表生命周期泛型，同时指定了`x`和`y`的生命周期为`'a`，同时返回的值生命周期也为`'a`，此时代码正常通过编译。不过，如果我们在这里说`x`、`y`和返回的值的生命周期是一样的，这种说法是不太准确的。在这里，`'a`被叫做生命周期标注，在下文我们进一步探讨此概念。

## 四、生命周期标注语法

生命周期的标注不会改变引用的生命周期长度，当某个函数指定了泛型生命周期参数，函数可以接受带有生命周期的引用。生命周期的标注描述了多个引用的生命周期的关系，但不影响生命周期。

参数周期标注，遵循以下语法规则

- 参数名：以`'`开头；使用全小写且非常短，很多人使用`'a`

- 标注的位置：在引用的`&`符号后；使用空格将标注和引用类型分开

生命周期标注例子如下

- `&i32`：一个普通引用
- `&'a i32`：带有显式生命周期的引用
- `&'a mut i32`：带有显式生命周期的可变引用

单个生命周期标注本省没有意义，当多个参数使用同一的标注时，代表多个参数必须拥有一样的生命周期。泛型生命周期参数声明在函数名和参数列表之间的`<>`里。到这里，我们在回顾*三*中的代码

```Rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

代码解读如下

- longest函数声明了一个`'a`生命周期
- `x`和`x`的生命周期必须大于等于`'a`
- 返回值的生命周期也必须大于等于`'a`

当我们在函数体里面指明生命周期参数的时候，我们并没有改变传入的值和返回的值的生命周期，我们只是向*借用检查器*指出了一些用于检查非法调用的一些=约束而已。在上面的例子中，`longest`函数本身并不需要知道`x`和`y`具体的生命周期，而只需要某个作用域可以被用来代替`'a`，同时满足函数的签名约束即可。

如果函数引用外部的代码或者被外部代码引用的时候，想单靠rust本身来确定参数和返回值的生命周期几乎是不可能的，这样的话函数所使用的生命周期可能在每次调用中都会发生变化，正式因此我们才需要手动对生命周期进行标注。

示例代码中的`'a`实际上代表`x`和`y`重叠的那部分生命周期（也就是`x`和`y`两个生命周期中较小的生命周期），而返回的值则在`x`和`y`重叠的那部分生命周期是有效的。

## 五、深入理解生命周期
